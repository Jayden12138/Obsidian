

```javascript


// core - parse
// <div>hi,{{message}}</div>

/**

init:
this.state = State.Text
this.index = 0
this.sectionStart = 0

while(this.index < this.buffer.length)

this.state = State.Text
this.sectionStart = 0

0 < State.BeforeTagName sectionStart = 0
123 div State.InTagName
4 > 
	(cbs.onopentagname => currentOpenTag) BeforeAttrName sectionStart = -1
	(cbs.onopentagend => addNode(currentOpenTag) -> stack.unshift(currentOpenTag))
	currentOpenTag = null
	State.Text sectionStart = this.index + 1 = 5
567 hi,  stateText(c)
8 {  State.InterpolationOpen delimiterIndex = 0
9 {  
	delimiterIndex = 1 start = 8
	State.Interpolation
	sectionStart = start = 8
10 11 12 13 14 15 16 message
	stateInterpolation(c)
17 }
	State.InterplocationClose
	delimiterIndex = 0
18 }
	delimiterIndex = 1
	innerStart = sectionStart = 8
	innerEnd = this.index + 1 = 19
	getSlice(innerStart, innerEnd) => 'message'
	addNode()
	State.Text
	this.sectionStart = this.index + 1 = 19
19 <
	State.BeforeTagName
	this.sectionStart = this.index = 19
20 /
	State.BeforeClosingTagName
21 22 23 div
	State.InClosingTagName
	this.sectionStart = this.index = 23
24 >
	(cbs.onclosetag => onCloseTag)
	this.sectionStart = -1
	State.AfterClosingTagName
	State.Text
	this.sectionStart = this.index + 1 = 25
	










*/















const stack = []

const tokenizer = new tokenizer(stack, {
	onopentagname(start, end){
		const name = getSlice(start, end)

		currentOpenTag = {
			type: NodeTypes.ELEMENT,
			tag: name,
			// ns: ...,
			tagType: ElmenetTypes.ELEMENT,
			props: [],
			children: [],
			loc:  getLoc(start - 1, end),
			// codegenNode: undefined	
		}
	},


	onopentagend(index){
		endOpenTag(index)
	}

	ontext(start, end){
		onText(getSlice(start, end), start, end)
	}


	oninterpolation(start, end){
		let innerStart = start + tokenizer.delimiterOpen.length
		let innerEnd = end - tokenizer.delimiterClose.length
		// 10 - 17 <div>hi,{{message}}</div>

		// 去除whitespace
		while (isWhitespace(currentInput.charCodeAt(innerStart))) {
		  innerStart++
		}
		while (isWhitespace(currentInput.charCodeAt(innerEnd - 1))) {
		  innerEnd--
		}


		let exp = getSlice(innerStart, innerEnd) // "message"


		addNode({
			type: NodeTypes.INTERPOLATION,
			content: createExp(exp, false, getLoc(innerStart, innerEnd)),
			// loc: getLoc(start, end)
		})
	
	}

	onclosetag(start, end){
		const name = getSlice(start, end)
		let found = false;
		for(let i = 0; i < stack.length; i++){
			const e = stack[i]
			if(e.tag.toLowerCase() === name.toLowerCase()){
				found = true;
				if(i>0){
					// 报错
				}
				for(let j = 0;j <= i;j++){
					const el = stack.shift()!
					onCloseTag(el, end, j < i) // onCloseTag 太长了吧
				}
				break;
			}
		} 
		if(!found){
			// 报错	
		}
	}
})


function onText(content, start, end){
	const parent = stack[0] || currentRoot
	const lastNode = parent.children[parent.children.length - 1]

	if(lastNode?.type === NodeTypes.Text){
		// merge
		lastNode.content += content;
		// setLocEnd(lastNode.loc, end)
	}else{
		parent.children.push({
			type: NodeTypes.Text,
			content,
			// loc: getLoc(start, end)
		})
	}
}


function endOpenTag(end: number){

	addNode(currentOpenTag!)

	stack.unshift(currentOpenTag!)
	
	currentOpenTag = null
}

function addNode(node){
	;(stack[0] || currentRoot).children.push(node)
}



class tokenizer{
	state
	// mode
	buffer
	sectionStart
	index
	// baseState
	// inRCDATA
	// currentSequence
	// newlines
	delimiterOpen
	delimiterClose
	reset(){
		state = state.text
		buffer = ''
		sectionStart = 0
		index = 0
		delimiterOpen = {{
		delimiterClose = }}
	}


	parse(input){
		this.buffer = input

		while(this.index < this.buffer.length){
			const c = this.buffer.charCodeAt(this.index)
			switch(this.state){
				case State.Text:
					this.stateText(c);
					break;
				case State.BeforeTagName:
					this.stateBeforeTagName(c)
					break;
				case State.InTagName:
					this.stateInTagName(c)
					break;
				case State.BeforeAttrName:
					this.stateBeforeAttrName(c)
					break;
				case State.InterpolationOpen:
					this.stateInterpolationOpen(c)
					break;
				case State.Interpolation:
					this.stateInterpolation(c)
					break;
				case State.InterpolationClose:
					this.stateInterpolationClose(c)
					break;
				case State.BeforeClosingTagName:
					this.stateBeforeClosingtagName(c)
					break;
				case State.InClosingTagName:
					this.stateInClosingTagName(c)
					break;
				case State.AfterClosingTagName:
					this.stateAfterClosingTagName(c)
					break;
				...
			}
			this.index ++
		}

		this.cleanup()
		this.finish()
	}


	stateAfterClosingTagName(c: number){
		// >
		if(c === '>'){
			this.state = State.Text
			this.sectionStart = this.index + 1
		}
	}

	stateInClosingTagName(c: number){
		// > || whitespace
		if(c === '>' || isWhitespace(c)){
			this.cbs.onclosetag(this.sectionStart, this.index)
			this.sectionStart = -1
			this.state = State.AfterClosingTagName
			this.stateAfterClosingTagName(c)
		}
	}

	stateBeforeClosingtagName(c: number){
		if(isWhitespace(c)){
			// ignore
		}else if(c === '>'){
			this.state = State.Text
			this.sectionStart = this.index + 1
		}else{
			this.state = isTagStartChar(c) ? 
				State.InClosingTagName :
				State.InSpecialComment
			this.sectionStart = this.index
		}
	}


	stateInterpolationClose(c: number){
		// }  // this.delimiterClose[this.delimiterIndex]
		// else State.Interpolation
		if(c === delimiterClose[this.delimiterIndex]){
			// 匹配完delimiterClose
			if(this.delimiterIndex === this.delimiterClose.length - 1){
				this.cbs.oninterpolation(this.sectionStart, this.index + 1)
				this.state = State.Text
				this.sectionStart = this.index + 1
			}else{
				this.delimiterIndex++
			}
		}else{
			this.state = State.Interpolation
			this.stateInterpolation(c)
		}
	}

	stateInterpolation(c: number){
		// }  // this.delimiterClose[0] 
		if(c === '}'){
			this.state = State.InterpolationClose
			this.delimiterIndex = 0
			this.stateInterpolationClose(c)
		}
	}


	stateText(c: number){
		if(c === '<'){
			if(this.index > this.sectionStart){
				this.cbs.ontext(this.sectionStart, this.index)
			}
			this.state = State.BeforeTagName
			this.sectionStart = this.index
		} else if (...){
			...
		} else if ( c === '{' ){
			this.state = State.InterpolationOpen
			this.delimiterIndex = 0
			this.stateInterpolationOpen(c)
		}
	}


	stateInterpolationOpen(c: number){
		// {  // this.delimiterOpen[this.delimiterIndex]
		// else text
		if(c === '{'){
			if(this.delimiterIndex === this.delimiterOpen.length - 1){
				// 匹配完{{
				const start = this.index + 1 - this.delimiterOpen.length
				if(start > this.sectionStart){
					this.cbs.ontext(this.sectionStart, start)
				}
				this.state = State.Interpolation
				this.sectionStart = start
			}else{
				this.delimiterIndex ++
			}
		}else{
			this.state = State.Text;
			this.stateText(c)
		}
		

	}

	stateBeforeTagName(c: number){
		// !
		// ?
		// /
		// a-z | A-Z
		if(isTagStartChar(c)){
			this.sectionStart = this.index;
			if(this.mode === ParseMode.BASE){
				// no special tags in base mode
				this.state = State.InTagName
			} else {
				...
			}
		} else if(c === '/'){
			this.state = State.BeforeClosingTagName
		} else {
			this.state = State.Text
			this.stateText(c)
		}
	}

	stateInTagName(c: number){
		if(isEndOfTagSection(c)){
			this.handleTagName(c)
		}
	}

	handleTagName(c: number){
		this.cbs.onopentagname(this.sectionStart, this.index) // <div
		this.sectionStart = -1
		this.state = State.BeforeAttrName
		this.stateBeforeAttrName(c)
	}

	stateBeforeAttrName(c: number){
		// >
		// /
		// <
		// isWhitespace(c)
		// isPeek()
		if(c === '>'){
			this.cbs.onopentagend(this.index)
			this.state = State.Text
			this.sectionStart = this.index + 1
		}
	}

	getPos(index){
		let line = 1;
		let column = index + 1;

		// ???
		for(let i = this.newlines.length - 1; i >= 0; i--){
			const newlineIndex = this.newlines[i]
			if(index > newlineIndex){
				line = i + 2
				column = index - newlineIndex
				break
			}
		}

		return {
			column,
			line,
			offset: index
		}
	}
}

function isTagStartChar(c){
	return 
	( c >= a && c <= z ) || 
	( c >= A && c <= Z )
}


function isEndOfTagSection(c){
	return c === '/' || c === '>' || isWhitespace(c)
}

function isWhitespace(c){
	// " "
	// \n
	// \f
	// \r
	// \t
	return (
		c === ' ' ||
		c === '\n' ||
		c === '\f' ||
		c === '\r' ||
		c === '\t' ||
	)
}


function getSlice(start, end){
	return currentInput.slice(start, end)
}


function getLoc(start, end?){
	return {
		start: tokenizer.getPos(start),
		end: end == null ? end : tokenizer.getPos(end),
		source: end == null ? end : getSlice(start, end)
	}
}




baseParse(input){
	reset()
	currentInput = input

	...

	const root = createRoot([], input)
	tokenizer.parse(currentInput)

	// root.loc = getLoc(0, input.length)
	// root.children = condenseWhitespace(root.children)
	
	currentRoot = null
	return root
}


function creatRoot(children, source){
	return {
		type: NodeTypes.ROOT,
		source,
		children,
		loc: locStub, // loc初始
		...
	}
}






























```