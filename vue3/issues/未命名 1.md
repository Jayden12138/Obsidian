```

ref()
	class RefImpl{
		get value(){}
		set value(){}
	}

reactive()
	return new Proxy(raw, {
		get
		set
		...
		ownKeys(){}
	})



1. render
	
	...props -> ownKeys() => 收集依赖 a

2. add props.foo
	ref-set
		trigger -> 找不到 foo 对应 dep

	？reactive-ownKeys
		收集依赖 a foo. 






这两种情况的问题可以统一为：
当给响应式对象设置之前没有的属性时，并没有正确的进行依赖收集以及后续的trigger

这里只实现了happy path的逻辑，reactive -> mutableHandlers中只对get set操作进行来“拦截”处理，当然proxy上也没有对·对象设置之前没有的属性·处理的接口




肯定是这里的问题
ownKeys(){}


流程梳理

setup()
	ref() -> reactive()

render()
	this.props -> PublicInstanceProxyHandlers get(key props) -> 
	isRef => ref.value props.value => reactive {a: 10}
	
	ref.value props.value -> ref get -> track

	...this.props -> reactive ownKeys -> track

	... -> key Symbol(iterate) -> 收集依赖
	这里展开props 赋值 访问了a

	a -> reactive get key(a) -> trackEffect 收集依赖


click change
	set
	toRaw
	key __v_isRaw -> reactive get

	trigger
	render()
		props
		unref
		.value => ref get -> trackRefValue
		
		
	

{Symbol(iterate) => Map(1)}



```




```
// original

trigger
	const depsMap = targetMap.get(target)
	const deps = despMap.get(key)
	triggerEffect(deps)


// 因为除了get set之外 需要添加ownKeys，所以会存在多个deps需要触发
// 引入变量dep

trigger
	let dep = []
	const depsMap = targetMap.get(target)
	
	//  需要区分type
	// clear
	// array
	// 其他（object
	if(// clear){
		
	} else if(key === 'length' && isArray(target)){
	
	} else {
		
		key && dep.push(targetMap.get(key))

		// add delete map.set
		
		dep.push(targetMap.get(iterate))
	}





```