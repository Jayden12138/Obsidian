```

ref()
	class RefImpl{
		get value(){}
		set value(){}
	}

reactive()
	return new Proxy(raw, {
		get
		set
		...
		ownKeys(){}
	})



1. render
	
	...props -> ownKeys() => 收集依赖 a

2. add props.foo
	ref-set
		trigger -> 找不到 foo 对应 dep

	？reactive-ownKeys
		收集依赖 a foo. 






这两种情况的问题可以统一为：
当给响应式对象设置之前没有的属性时，并没有正确的进行依赖收集以及后续的trigger

这里只实现了happy path的逻辑，reactive -> mutableHandlers中只对get set操作进行来“拦截”处理，当然proxy上也没有对·对象设置之前没有的属性·处理的接口




肯定是这里的问题
ownKeys(){}


流程梳理

setup()
	ref() -> reactive()

render()
	this.props -> PublicInstanceProxyHandlers get(key props) -> 
	isRef => ref.value props.value => reactive {a: 10}
	
	ref.value props.value -> ref get -> track

	...this.props -> reactive ownKeys -> track

	... -> key Symbol(iterate) -> 收集依赖
	这里展开props 赋值 访问了a

	a -> reactive get key(a) -> trackEffect 收集依赖


click change
	set
	toRaw
	key __v_isRaw -> reactive get

	trigger
	render()
		props
		unref
		.value => ref get -> trackRefValue
		
		
	

{Symbol(iterate) => Map(1)}



```




```

set(){


	if (target === toRaw(receiver)) {
	
		trigger ?
	
	}
	
	return result
}












```