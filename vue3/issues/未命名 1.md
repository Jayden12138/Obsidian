


```ts

// original

trigger
	const depsMap = targetMap.get(target)
	const deps = despMap.get(key)
	triggerEffect(deps)


// 因为除了get set之外 需要添加ownKeys，所以会存在多个deps需要触发
// 引入变量dep

trigger
	let dep = []
	const depsMap = targetMap.get(target)
	
	//  需要区分type
	// clear
	// array
	// 其他（object
	if(// clear){
		
	} else if(key === 'length' && isArray(target)){
		
	} else {
		
		key && dep.push(targetMap.get(key))

		// add delete map.set
		
		dep.push(targetMap.get(iterate))
	}

target
	array isArray(target) & isIntegerKey(key)
	map isMap(target)
	iterate !isArray (object map ...)

// add
if (!isArray(target)) {
  deps.push(depsMap.get(ITERATE_KEY))
  if (isMap(target)) {
	deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))
  }
} else if (isIntegerKey(key)) {
	// target change .length get key:length
	// length -> dep
  // new index added to array -> length changes
  deps.push(depsMap.get('length'))
}
break

target
	map
	iterate


// delete
if (!isArray(target)) {
  deps.push(depsMap.get(ITERATE_KEY))
  if (isMap(target)) {
	deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))
  }
}
break

target
	map

// set
if (isMap(target)) {
  deps.push(depsMap.get(ITERATE_KEY))
}








```




```js

// 不看map


target
	array isArray(target) & isIntegerKey(key)
	iterate !isArray (object map ...)

// add
if (!isArray(target)) {
  deps.push(depsMap.get(ITERATE_KEY))
} else if (isIntegerKey(key)) {
  deps.push(depsMap.get('length'))
}
break

target
	iterate

// delete
if (!isArray(target)) {
  deps.push(depsMap.get(ITERATE_KEY))
}
break

```



```ts


1. issue
https://github.com/cuixiaorui/mini-vue/issues/103

2. 定位问题

const props = ref({a:10});
const change1 = () => {
  props.value.foo = "new foo";
};

当props的值发生修改（add property）时，触发了reactive set，但在effect中，收集依赖时，并没有收集foo字段相关依赖，所以这里通过targetMap.get(target).get(key) -> dep,是undefined


3. 设计一个单测

why
	1. 问题虽然在updateProps中出现，但是本质上是reactivity中的问题，也是为了更方便的调试，这里单独去设计单元测试进行调试
	2. 给ref传对象，在内部实际是通过reactive包裹，这里为了方便调试，直接使用reactive进行测试


	it('add new property', () => {
		let dummy
		const original = { foo: 1 }
		const observed: any = reactive(original)
		effect(() => {
			dummy = {...observed}
		})

		// add new property
		observed.bar = 2
		expect(dummy).toEqual({ foo: 1, bar: 2 })
	})


ref 传入一个对象时，内部是通过reactive进行包裹了一层

reactive中 通过proxy来拦截target上的一些操作（此时只有get和set），这里并不会对没有的属性收集依赖也就无法在新增属性时获取到相关依赖去执行


Proxy ownKeys
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys
可以用来拦截一些操作
	Object.getOwnPropertyNames()
	Object.getOwnPropertySymbols()
	Object.keys()
	Reflect.ownKeys()


在render中，通过...props,将props的属性展开赋值到vnode上
这里的...会被ownKeys拦截到


对于这些可以被...展开的变量称为可迭代对象（Iterable object）


这里可以创建一个特殊的属性，来进行收集依赖

const ITERATE_KEY = Symbol('iterate')


function reactive(raw){
	return new Proxy(raw, {
		get,
		set,
		ownKeys(target){
			track(target, ITERATE_KEY)
			return Reflect.ownKeys(target)
		}
	})
}


function track(target, key){}


这样当第一次执行完render后，props相关的依赖收集情况会是
targetMap
	props => {
		'a' -> dep
		Symbol('iterate') -> dep
	}


此时，点击 运行函数 change1
props.value.foo = "new foo";

这里会触发reactive set trigger

在trigger中，原来的逻辑是通过target,key来获取到对应收集的依赖，遍历执行即可
但是现在可能存在获取不到对应的dep，所以需要去通过执行其他特殊的key所收集到的依赖来更新target

这里引入deps用来收集

function trigger(target, key){
	let deps: any = []
	const depsMap = targetMap.get(target)

	// key -> 对应的dep
	deps.push(depsMap.get(key))

	// Symbol('iterate')
	deps.push(depsMap.get(ITERATE_KEY))

	triggerEffect(deps)
}

这里还需要对triggerEffect进行修改，之前传入的是个dep => new Set()
现在传入的是deps => [ Set, Set, ... ]

function triggerEffect(deps){
	deps.forEach(dep => {
		if(!dep) return
		for(const _effect of dep){
			if(!_effect) return
			
			if(_effect.scheduler){
				_effect.scheduler()
			} else {
				_effect.run()
			}
		}
	})
}


到这里上述问题其实已经不报错了，但是出现了很多新的问题，例如：

1. 如果修改的是之前就有的属性，在trigger中，还是会push ITERATE_KEY 所对应的dep，这种情况下其实不需要这个，他自己就有收集到的依赖
	1. 解决：需要添加type，标识当前操作的类型（add、delete、...)
2. 目前处理的只是对象这一种情况，并没有考虑到数组、Map等
	1. 数组
		1. 解决：和对象差不多，增删数组会改变length，这里可以对length这个属性进行收集
	2. Map


处理下 1 中的 add部分

补充单测
需要在 set -> trigger -> dep 中，只需要获取并执行一次

	it('add new property', () => {
		let dummy
		const original = { foo: 1 }
		const observed: any = reactive(original)
		effect(() => {
			dummy = {...observed}
		})

		// add new property
		observed.bar = 2
		expect(dummy).toEqual({ foo: 1, bar: 2 })
	
		// set property
		observed.foo = 2
		expect(dummy).toEqual({ foo: 2, bar: 2 })
	})

需要判断出，当前的操作类型
set
	add
	set

使用 Object.hasOwn(target, key) 来判断，在set之前，当前key是否在这个target上，如果不在则为 新增（add），如果在，则此次set操作为修改（set）

注意：这个判断需要在 Reflect.set 之前进行判断

const set = createSetter()

function reactive(raw){
	return new Proxy(raw, {
		get,
		set,
		ownKeys(target){
			track(target, ITERATE_KEY)
			return Reflect.ownKeys(target)
		}
	})
}

function createSetter(){
	return function setter(target, key, value){
		const hasKey = hasOwn(target, key)
		const res = Reflect.set(target, key, value)
		
		if(!hasKey){
			trigger(target, 'add', key)
		} else {
			trigger(target, 'set', key)
		}
		
		return res
	}
}

// shared/index.ts
function hasOwn = Object.hasOwn


function trigger(target, type, key){
	let deps: any = []
	const depsMap = targetMap.get(target)

	// key -> 对应的dep
	deps.push(depsMap.get(key))

	switch(type){
		case 'add':
			// Symbol('iterate')
			deps.push(depsMap.get(ITERATE_KEY))
			break;
	}

	triggerEffect(deps)
}


这里如果type是set的话，就不需要通过 ITERATE_KEY 来获取dep了，因为在这之前已经对当前的key做了收集


1 中的 add部分 结束


小优化点：
	当set的时，如果值并没有发生改变，则不需要执行trigger


function createSetter(){
	return function setter(target, key, value){
		const oldValue = Reflect.get(target, key)
		const hasKey = hasOwn(target, key)
		const res = Reflect.set(target, key, value)
		
		if(!hasKey){
			trigger(target, 'add', key)
		} else if(hasChanged(value, oldValue)) {
			trigger(target, 'set', key)
		}
		
		return res
	}
}


// shared/index.ts
const hasChanged = (value1, value2) => !Object.is(value1, value2)






```




```ts


处理 array

设计单测
	
	it('add in reactive array', () => {
		let dummy
		const original: any = ['foo']
		const observed = reactive(original)
		effect(() => {
			dummy = observed
		})

		// add
		observed.push('bar')
		expect(dummy[1]).toBe('bar')
	})


相同的，array在effect中赋值并不会触发当前reactive中拦截的get，set，ownKeys

如果此时 effect 中时这样定义的

	effect(() => {
		dummy = observed[0]
	})

这样是可以正常触发reactive-get，收集到的依赖如下

targetMap{
	original -> {
		'0' -> dep
	}
}

但这样后续只有'0'这一位置上会正常触发依赖，其他位置并不会

和处理对象一样，这里需要引入一个特殊的key length 来收集依赖
但在effect并不会触发任何收集依赖


observed.push('bar')
这里分成两个部分
.push 以及 push()

执行 .push 时会触发 reactive-get key: push
执行 push() 时会触发 reactive-get key: length
	在执行Array.prototype.push会隐式访问length属性，所以这里拦截到了

参考：https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.push













const arrayInstrumentations = createArrayInstrumentations()

function createArrayInstrumentations(){
	const instrumentations = {}

	['includes', 'indexOf', 'lastIndexOf'].forEach(()=>{})

	['pop', 'push', 'shift', 'splice', 'unshift'].forEach(()=>{})

	return instrumentations
}

/**

arrayInstrumentations{
	includes
	indexOf
	lastIndexOf
	pop
	push
	...
}

.push => arrayInstrumentations.push => 
// 增强push


['includes', 'indexOf', 'lastIndexOf']
查询 遍历
需要遍历给每一项都进行track

['pop', 'push', 'shift', 'splice', 'unshift']
修改原数组

会访问到一些属性类似length
所以需要暂停track


*/

get(){

	
	// key: push
	return Reflect.get(arrayInstrumentations, key)

}







```






