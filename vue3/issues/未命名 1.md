```

ref()
	class RefImpl{
		get value(){}
		set value(){}
	}

reactive()
	return new Proxy(raw, {
		get
		set
		...
		ownKeys(){}
	})



1. render
	
	...props -> ownKeys() => 收集依赖 a

2. add props.foo
	ref-set
		trigger -> 找不到 foo 对应 dep

	？reactive-ownKeys
		收集依赖 a foo. 






这两种情况的问题可以统一为：
当给响应式对象设置之前没有的属性时，并没有正确的进行依赖收集以及后续的trigger

这里只实现了happy path的逻辑，reactive -> mutableHandlers中只对get set操作进行来“拦截”处理，当然proxy上也没有对·对象设置之前没有的属性·处理的接口

ownKeys(){}








```